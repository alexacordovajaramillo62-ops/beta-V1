-- ============================================================
-- BRAINROT LIBRARY - FUNCTIONS ONLY (NO GUI)
-- ============================================================

local BrainrotLib = {}

-- ============================================================
-- SERVICES & MODULES
-- ============================================================

local S = {
    Players           = game:GetService("Players"),
    UserInputService  = game:GetService("UserInputService"),
    TweenService      = game:GetService("TweenService"),
    ReplicatedStorage = game:GetService("ReplicatedStorage"),
    HttpService       = game:GetService("HttpService"),
    RunService        = game:GetService("RunService"),
    Stats             = game:GetService("Stats"),
    TeleportService   = game:GetService("TeleportService"),
    Lighting          = game:GetService("Lighting"),
}

S. Packages = S.ReplicatedStorage:WaitForChild("Packages")
S.Datas    = S.ReplicatedStorage:WaitForChild("Datas")
S.Shared   = S.ReplicatedStorage:WaitForChild("Shared")
S.Utils    = S.ReplicatedStorage:WaitForChild("Utils")

S.Synchronizer  = require(S.Packages:WaitForChild("Synchronizer"))
S.AnimalsData   = require(S. Datas:WaitForChild("Animals"))
S.RaritiesData  = require(S. Datas:WaitForChild("Rarities"))
S.AnimalsShared = require(S.Shared:WaitForChild("Animals"))
S.NumberUtils   = require(S.Utils:WaitForChild("NumberUtils"))

S.LocalPlayer = S.Players.LocalPlayer
S.PlayerGui   = S.LocalPlayer:WaitForChild("PlayerGui")

-- ============================================================
-- GLOBAL STATE
-- ============================================================

BrainrotLib.allAnimalsCache = {}
BrainrotLib.stats = {
    totalAnimals  = 0,
    totalValue    = 0,
    highestGen    = 0,
    mutationCount = 0,
    traitCount    = 0,
}

local scannerConnections = {}
local plotChannels = {}
local lastAnimalData = {}

local floatPlatform = nil
local invisibleWallsLoaded = false
local originalTransparency = {}

local InternalStealCache = {}
local AUTO_STEAL_PROX_RADIUS = 20
local PromptMemoryCache = {}
local LastTargetUID = nil
local LastPlayerPosition = nil
local PlayerVelocity = Vector3.zero
local PREDICTION_LOOKAHEAD = 1.25

local STEAL_SPEED = 25. 5
local stealSpeedConn = nil

local ESP_INSTANCES = {}
local PLAYER_ESP = {}
local ESP_BEST_UID = nil

-- ============================================================
-- DESYNC FLAGS
-- ============================================================

local DESYNC_FLAGS = {
    LargeReplicatorEnabled9 = true,
    GameNetDontSendRedundantNumTimes = 1,
    MaxTimestepMultiplierAcceleration = 2147483647,
    InterpolationFrameVelocityThresholdMillionth = 5,
    CheckPVDifferencesForInterpolationMinRotVelThresholdRadsPerSecHundredth = 1,
    TimestepArbiterVelocityCriteriaThresholdTwoDt = 2147483646,
    GameNetPVHeaderLinearVelocityZeroCutoffExponent = -5000,
    TimestepArbiterHumanoidTurningVelThreshold = 1,
    LargeReplicatorSerializeWrite4 = true,
    SimExplicitlyCappedTimestepMultiplier = 2147483646,
    InterpolationFrameRotVelocityThresholdMillionth = 5,
    ServerMaxBandwith = 52,
    LargeReplicatorSerializeRead3 = true,
    GameNetDontSendRedundantDeltaPositionMillionth = 1,
    PhysicsSenderMaxBandwidthBps = 20000,
    CheckPVCachedVelThresholdPercent = 10,
    NextGenReplicatorEnabledWrite4 = true,
    LargeReplicatorWrite5 = true,
    MaxMissedWorldStepsRemembered = -2147483648,
    StreamJobNOUVolumeCap = 2147483647,
    CheckPVLinearVelocityIntegrateVsDeltaPositionThresholdPercent = 1,
    DisableDPIScale = true,
    WorldStepMax = 30,
    InterpolationFramePositionThresholdMillionth = 5,
    MaxAcceptableUpdateDelay = 1,
    TimestepArbiterOmegaThou = 1073741823,
    CheckPVCachedRotVelThresholdPercent = 10,
    StreamJobNOUVolumeLengthCap = 2147483647,
    S2PhysicsSenderRate = 15000,
    MaxTimestepMultiplierBuoyancy = 2147483647,
    SimOwnedNOUCountThresholdMillionth = 2147483647,
    ReplicationFocusNouExtentsSizeCutoffForPauseStudsPerSecHundredth = 2147483647,
    LargeReplicatorRead5 = true,
    CheckPVDifferencesForInterpolationMinVelThresholdStudsPerSecHundredth = 1,
    MaxDataPacketPerSend = 2147483647,
    MaxTimestepMultiplierContstraint = 2147483647,
    DebugSendDistInSteps = -2147483648,
    GameNetPVHeaderRotationalVelocityZeroCutoffExponent = -5000,
    AngularVelociryLimit = 360
}

-- ============================================================
-- HELPER FUNCTIONS
-- ============================================================

local function getHRP()
    local c = S.LocalPlayer.Character
    if not c then return end
    return c:FindFirstChild("HumanoidRootPart") or c:FindFirstChild("UpperTorso")
end

local function isMyBaseAnimal(animalData)
    if not animalData or not animalData.plot then
        return false
    end
    
    local plots = workspace:FindFirstChild("Plots")
    if not plots then
        return false
    end
    
    local plot = plots:FindFirstChild(animalData.plot)
    if not plot then
        return false
    end
    
    local channel = S.Synchronizer:Get(plot. Name)
    if channel then
        local owner = channel:Get("Owner")
        if owner then
            if typeof(owner) == "Instance" and owner: IsA("Player") then
                return owner. UserId == S.LocalPlayer.UserId
            elseif typeof(owner) == "table" and owner.UserId then
                return owner.UserId == S.LocalPlayer.UserId
            elseif typeof(owner) == "Instance" then
                return owner == S.LocalPlayer
            end
        end
    end
    
    local sign = plot:FindFirstChild("PlotSign")
    if sign then
        local yourBase = sign:FindFirstChild("YourBase")
        if yourBase and yourBase: IsA("BillboardGui") then
            return yourBase.Enabled == true
        end
    end
    
    return false
end

local function getPodiumWorldPart(animal)
    if not animal.plot or not animal.slot then return nil end
    
    local plot = workspace. Plots:FindFirstChild(animal.plot)
    if not plot then return nil end
    
    local podiums = plot:FindFirstChild("AnimalPodiums")
    if not podiums then return nil end
    
    local podium = podiums:FindFirstChild(animal.slot)
    if not podium then return nil end
    
    local base = podium:FindFirstChild("Base")
    if not base then return podium end
    
    local spawn = base:FindFirstChild("Spawn")
    return spawn or base or podium
end

local function getAnimalPosition(animalData)
    local plot = workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then return nil end
    
    local podiums = plot:FindFirstChild("AnimalPodiums")
    if not podiums then return nil end
    
    local podium = podiums: FindFirstChild(animalData. slot)
    if not podium then return nil end
    
    return podium:GetPivot().Position
end

local function getSideBounds(sideFolder)
    if not sideFolder then return nil end
    
    local minX, minY, minZ = math.huge, math. huge, math.huge
    local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge
    local found = false
    
    local function scan(obj)
        for _, child in ipairs(obj:GetChildren()) do
            if child:IsA("BasePart") then
                found = true
                local p = child. Position
                minX = math.min(minX, p.X)
                minY = math.min(minY, p.Y)
                minZ = math.min(minZ, p.Z)
                maxX = math.max(maxX, p.X)
                maxY = math.max(maxY, p.Y)
                maxZ = math.max(maxZ, p.Z)
            else
                scan(child)
            end
        end
    end
    
    scan(sideFolder)
    if not found then return nil end
    
    local center = Vector3.new((minX + maxX) * 0.5, (minY + maxY) * 0.5, (minZ + maxZ) * 0.5)
    local halfSize = Vector3.new((maxX - minX) * 0.5, (maxY - minY) * 0.5, (maxZ - minZ) * 0.5)
    
    return {
        center = center,
        halfSize = halfSize,
        minX = minX,
        maxX = maxX,
        minZ = minZ,
        maxZ = maxZ,
    }
end

local function getSafeOutsideDecorPos(plot, targetPos, fromPos)
    local decorations = plot:FindFirstChild("Decorations")
    if not decorations then return targetPos end
    
    local side3Folder = decorations:FindFirstChild("Side 3")
    if not side3Folder then return targetPos end
    
    local info = getSideBounds(side3Folder)
    if not info then return targetPos end
    
    local center = info.center
    local halfSize = info.halfSize
    local MARGIN = 4
    
    local localTarget = targetPos - center
    local insideX = math.abs(localTarget.X) <= halfSize.X
    local insideZ = math.abs(localTarget. Z) <= halfSize.Z
    
    if not (insideX and insideZ) then
        return targetPos
    end
    
    local src = fromPos and (fromPos - center) or localTarget
    local dir = Vector3.new(src.X, 0, src.Z)
    
    if dir. Magnitude < 1e-3 then
        dir = Vector3.new(0, 0, 1)
    end
    
    local dirUnit = dir. Unit
    
    local tx, tz = math.huge, math.huge
    
    if dirUnit.X ~= 0 then
        local boundX = (dirUnit.X > 0) and halfSize.X or -halfSize. X
        tx = boundX / dirUnit.X
    end
    
    if dirUnit.Z ~= 0 then
        local boundZ = (dirUnit. Z > 0) and halfSize.Z or -halfSize.Z
        tz = boundZ / dirUnit.Z
    end
    
    local tHit = math.min(tx, tz)
    if tHit == math.huge then return targetPos end
    
    local boundaryLocal = dirUnit * (tHit + MARGIN)
    local worldPos = center + boundaryLocal
    
    return Vector3.new(worldPos.X, targetPos.Y, worldPos.Z)
end

local function getSmartCarpetPosition(carpetPart, fromPos)
    if not carpetPart or not fromPos then return nil end
    
    local cf = carpetPart. CFrame
    local size = carpetPart.Size
    local halfX = size.X / 2
    local halfZ = size.Z / 2
    
    local localPos = cf: PointToObjectSpace(fromPos)
    
    local clampedX = math.clamp(localPos.X, -halfX, halfX)
    local clampedZ = math. clamp(localPos.Z, -halfZ, halfZ)
    
    if math.abs(localPos.X) < halfX and math.abs(localPos.Z) < halfZ then
        local distToEdges = {
            north = halfZ - localPos.Z,
            south = halfZ + localPos.Z,
            east = halfX - localPos.X,
            west = halfX + localPos.X
        }
        
        local minDist = math.huge
        local nearestEdge = "north"
        
        for edge, dist in pairs(distToEdges) do
            if dist < minDist then
                minDist = dist
                nearestEdge = edge
            end
        end
        
        if nearestEdge == "north" then
            clampedZ = halfZ
        elseif nearestEdge == "south" then
            clampedZ = -halfZ
        elseif nearestEdge == "east" then
            clampedX = halfX
        else
            clampedX = -halfX
        end
    end
    
    local nearestPoint = cf:PointToWorldSpace(Vector3.new(clampedX, 0, clampedZ))
    
    local rayOrigin = nearestPoint + Vector3.new(0, 50, 0)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = { workspace. Map }
    rayParams.FilterType = Enum. RaycastFilterType.Whitelist
    
    local result = workspace:Raycast(rayOrigin, Vector3.new(0, -100, 0), rayParams)
    local finalY = result and result.Position.Y or fromPos.Y
    
    return Vector3.new(nearestPoint.X, finalY, nearestPoint.Z)
end

local function tpNearPlotIfFar(animalData)
    local hrp = getHRP()
    if not hrp or not animalData or not animalData.plot then return end

    local plot = workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then return end

    local plotPos = plot:GetPivot().Position

    if (hrp.Position - plotPos).Magnitude <= 100 then
        return
    end

    local decorations = plot:FindFirstChild("Decorations")
    local side3 = decorations and decorations:FindFirstChild("Side 3") or nil

    local info = side3 and getSideBounds(side3) or nil
    local center = info and info.center or plotPos

    local dir = (hrp.Position - center).Unit
    local distanceFromPlot = 70
    local y = center.Y + 4

    local finalPos = Vector3.new(
        center.X + dir.X * distanceFromPlot,
        y,
        center.Z + dir.Z * distanceFromPlot
    )

    hrp.CFrame = CFrame.new(finalPos, center)
end

-- ============================================================
-- DESYNC SYSTEM
-- ============================================================

function BrainrotLib. RunDesync()
    for key, value in pairs(DESYNC_FLAGS) do
        pcall(function()
            setfflag(tostring(key), tostring(value))
        end)
    end
end

function BrainrotLib.EnableDesync()
    task.spawn(BrainrotLib.RunDesync)
end

-- ============================================================
-- TELEPORT SYSTEM
-- ============================================================

function BrainrotLib.TeleportToAnimal(animalData, safeTeleport)
    safeTeleport = safeTeleport or false
    
    local character = S.LocalPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local hrp = character. HumanoidRootPart
    if not humanoid or not hrp then return false end
    
    local carpet = S.LocalPlayer. Backpack:FindFirstChild("Flying Carpet")
    if carpet then
        humanoid: EquipTool(carpet)
    end
    
    local plot = workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then
        return false
    end
    
    local targetPos = Vector3.new(0, 10, 0)
    
    local podiums = plot:FindFirstChild("AnimalPodiums")
    local animalFolder = podiums and podiums:FindFirstChild(animalData.slot)
    
    local allParts = {}
    local function scan(obj)
        for _, child in ipairs(obj:GetChildren()) do
            if child:IsA("BasePart") then
                table.insert(allParts, child)
            else
                scan(child)
            end
        end
    end
    
    if animalFolder then
        scan(animalFolder)
    end
    
    if #allParts > 0 then
        local closest, minDist = nil, math.huge
        local hrpPos = hrp.Position
        
        for _, part in ipairs(allParts) do
            local dist = (part.Position - hrpPos).Magnitude
            if dist < minDist then
                minDist = dist
                closest = part
            end
        end
        
        if closest then
            targetPos = closest.Position
        end
    else
        local spawnPart = plot:FindFirstChild("Spawn")
        if spawnPart and spawnPart:IsA("BasePart") then
            targetPos = Vector3.new(spawnPart.Position.X, targetPos.Y, spawnPart.Position.Z)
        else
            local plotPart = plot:FindFirstChildWhichIsA("BasePart")
            if plotPart then
                targetPos = Vector3.new(plotPart.Position.X, targetPos.Y, plotPart.Position.Z)
            end
        end
    end
    
    local animalY = targetPos.Y
    local highAnimal = animalY > 10
    local currentPos = hrp.Position
    
    if safeTeleport then
        local carpetPart = workspace. Map:FindFirstChild("Carpet")
        if carpetPart and carpetPart:IsA("BasePart") then
            local carpetPos = getSmartCarpetPosition(carpetPart, currentPos)
            if carpetPos then
                local state = humanoid:GetState()
                if state ~= Enum.HumanoidStateType.Jumping and state ~= Enum.HumanoidStateType.Freefall then
                    humanoid: ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(0.05)
                end
                
                hrp. Velocity = Vector3.new(hrp.Velocity.X, 200, hrp.Velocity.Z)
                
                task.wait(0.1)
                
                hrp.CFrame = CFrame.new(carpetPos. X, hrp.Position.Y, carpetPos.Z)
                
                task.wait(0.3)
                
                tpNearPlotIfFar(animalData)
                
                task.wait(0.3)
            end
        end
    else
        if highAnimal then
            local state = humanoid:GetState()
            if state ~= Enum. HumanoidStateType. Jumping and state ~= Enum. HumanoidStateType. Freefall then
                humanoid:ChangeState(Enum. HumanoidStateType. Jumping)
                task.wait(0.05)
            end
            
            hrp.Velocity = Vector3.new(hrp.Velocity.X, 200, hrp.Velocity.Z)
            
            task.wait(0.2)
        end
    end
    
    local finalPos
    if highAnimal then
        finalPos = Vector3.new(targetPos.X, 20, targetPos.Z)
    else
        finalPos = targetPos
    end
    
    finalPos = getSafeOutsideDecorPos(plot, finalPos, currentPos)
    
    hrp.CFrame = CFrame. new(finalPos)
    
    return true
end

function BrainrotLib.TeleportToHighest(favoritesEnabled, safeTeleport)
    if #BrainrotLib.allAnimalsCache == 0 then
        return false
    end
    
    if favoritesEnabled and getgenv().BRAINROT_FAVORITES and #getgenv().BRAINROT_FAVORITES > 0 then
        local favAnimal = BrainrotLib.GetFavoriteByPriority()
        if favAnimal then
            return BrainrotLib.TeleportToAnimal(favAnimal, safeTeleport)
        end
    end
    
    return BrainrotLib.TeleportToAnimal(BrainrotLib.allAnimalsCache[1], safeTeleport)
end

-- ============================================================
-- INSTANT CLONER
-- ============================================================

function BrainrotLib.InstantCloner()
    local success, err = pcall(function()
        local character = S.LocalPlayer.Character
        if not character then error("Character not found") end
        
        local humanoid = character: FindFirstChild("Humanoid")
        if not humanoid then error("Humanoid not found") end
        
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                humanoid:UnequipTools()
                task.wait(0.1)
                break
            end
        end
        
        local backpack = S.LocalPlayer. Backpack
        local cloner = backpack:FindFirstChild("Quantum Cloner")
        if not cloner then error("Quantum Cloner not found in inventory! ") end
        
        humanoid:EquipTool(cloner)
        task.wait()
        
        local useRemote = S.ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RE/UseItem")
        useRemote:FireServer()
        task.wait()
        
        local clonerRemote = S.ReplicatedStorage:WaitForChild("Packages"):WaitForChild("Net"):WaitForChild("RE/QuantumCloner/OnTeleport")
        clonerRemote:FireServer()
    end)
    
    return success, err
end

-- ============================================================
-- KICK & REJOIN
-- ============================================================

function BrainrotLib.KickSelf()
    S.LocalPlayer:Kick("Kicked by user")
end

function BrainrotLib.RejoinServer()
    local placeId = game.PlaceId
    local jobId = game.JobId
    
    task.delay(0. 15, function()
        local ok, err = pcall(function()
            if jobId and jobId ~= "" then
                S.TeleportService:TeleportToPlaceInstance(placeId, jobId, S.LocalPlayer)
            else
                S.TeleportService:Teleport(placeId, S.LocalPlayer)
            end
        end)
        
        return ok, err
    end)
end

-- ============================================================
-- FLOOR STEAL
-- ============================================================

function BrainrotLib.StartFloorSteal()
    if floatPlatform then floatPlatform:Destroy() end
    
    floatPlatform = Instance.new("Part")
    floatPlatform.Size = Vector3.new(6, 1, 6)
    floatPlatform. Anchored = true
    floatPlatform.CanCollide = true
    floatPlatform. Transparency = 1
    floatPlatform. Parent = workspace
    
    task.spawn(function()
        while floatPlatform do
            local hrp = getHRP()
            if hrp then
                floatPlatform.Position = hrp.Position - Vector3.new(0, 3, 0)
            end
            task.wait(0.05)
        end
    end)
end

function BrainrotLib. StopFloorSteal()
    if floatPlatform then
        floatPlatform: Destroy()
        floatPlatform = nil
    end
end

-- ============================================================
-- INVISIBLE WALLS
-- ============================================================

local function isBaseWall(obj)
    if not obj: IsA("BasePart") then return false end
    local n = obj.Name:lower()
    local parent = obj.Parent and obj.Parent. Name:lower() or ""
    return n: find("base") or parent:find("base")
end

local function tryApplyInvisibleWalls()
    local plots = workspace: FindFirstChild("Plots")
    if not plots then return end
    if #plots:GetChildren() == 0 then return end
    
    if invisibleWallsLoaded then return end
    invisibleWallsLoaded = true
    
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("BasePart") and obj. Anchored and obj. CanCollide and isBaseWall(obj) then
            originalTransparency[obj] = obj.LocalTransparencyModifier
            obj.LocalTransparencyModifier = 0.85
        end
    end
    
    workspace.DescendantAdded:Connect(function(obj)
        if isBaseWall(obj) then
            originalTransparency[obj] = obj.LocalTransparencyModifier
            obj.LocalTransparencyModifier = 0.85
        end
    end)
end

function BrainrotLib.EnableInvisibleWalls()
    task.spawn(function()
        for _ = 1, 20 do
            tryApplyInvisibleWalls()
            if invisibleWallsLoaded then return end
            task.wait(0.5)
        end
    end)
end

function BrainrotLib.DisableInvisibleWalls()
    invisibleWallsLoaded = false
    
    for part, value in pairs(originalTransparency) do
        if part then
            part.LocalTransparencyModifier = value
        end
    end
    originalTransparency = {}
end

-- ============================================================
-- AUTO-STEAL SYSTEM
-- ============================================================

local function findProximityPromptForAnimal(animalData)
    if not animalData then return nil end
    
    local cachedPrompt = PromptMemoryCache[animalData.uid]
    if cachedPrompt and cachedPrompt.Parent then
        return cachedPrompt
    end
    
    local plot = workspace.Plots:FindFirstChild(animalData.plot)
    if not plot then return nil end
    
    local podiums = plot:FindFirstChild("AnimalPodiums")
    if not podiums then return nil end
    
    local podium = podiums:FindFirstChild(animalData.slot)
    if not podium then return nil end
    
    local base = podium:FindFirstChild("Base")
    if not base then return nil end
    
    local spawn = base:FindFirstChild("Spawn")
    if not spawn then return nil end
    
    local attach = spawn:FindFirstChild("PromptAttachment")
    if not attach then return nil end
    
    for _, p in ipairs(attach:GetChildren()) do
        if p:IsA("ProximityPrompt") then
            PromptMemoryCache[animalData.uid] = p
            return p
        end
    end
    
    return nil
end

local function getNearestAnimal()
    local hrp = getHRP()
    if not hrp then return nil end
    
    local nearest = nil
    local minDist = math.huge
    
    for _, animalData in ipairs(BrainrotLib.allAnimalsCache) do
        if isMyBaseAnimal(animalData) then
            continue
        end
        
        local pos = getAnimalPosition(animalData)
        if pos then
            local dist = (hrp.Position - pos).Magnitude
            
            if dist < minDist then
                minDist = dist
                nearest = animalData
            end
        end
    end
    
    return nearest
end

local function updatePlayerVelocity()
    local hrp = getHRP()
    if not hrp then return end
    
    local currentPos = hrp.Position
    
    if LastPlayerPosition then
        PlayerVelocity = (currentPos - LastPlayerPosition) / task.wait()
    end
    
    LastPlayerPosition = currentPos
end

local function getTimeToReach(targetPos)
    local hrp = getHRP()
    if not hrp then return math.huge end
    
    local currentPos = hrp.Position
    local distance = (targetPos - currentPos).Magnitude
    
    if PlayerVelocity. Magnitude < 0.1 then
        return math.huge
    end
    
    local directionToTarget = (targetPos - currentPos).Unit
    local velocityTowardTarget = PlayerVelocity: Dot(directionToTarget)
    
    if velocityTowardTarget <= 0 then
        return math.huge
    end
    
    return distance / velocityTowardTarget
end

local function shouldPreFire(animalData, predictiveSteal)
    local animalPos = getAnimalPosition(animalData)
    if not animalPos then return false end
    
    local hrp = getHRP()
    if not hrp then return false end
    
    local currentDistance = (hrp.Position - animalPos).Magnitude
    
    if currentDistance <= AUTO_STEAL_PROX_RADIUS then
        return true
    end
    
    if not predictiveSteal then
        return false
    end
    
    local timeToReach = getTimeToReach(animalPos)
    
    if timeToReach <= PREDICTION_LOOKAHEAD and timeToReach > 0 then
        return true
    end
    
    return false
end

local function buildStealCallbacks(prompt)
    if InternalStealCache[prompt] then return end
    
    local data = {
        holdCallbacks = {},
        triggerCallbacks = {},
        ready = true,
    }
    
    local ok1, conns1 = pcall(getconnections, prompt. PromptButtonHoldBegan)
    if ok1 and type(conns1) == "table" then
        for _, conn in ipairs(conns1) do
            if type(conn. Function) == "function" then
                table.insert(data.holdCallbacks, conn. Function)
            end
        end
    end
    
    local ok2, conns2 = pcall(getconnections, prompt. Triggered)
    if ok2 and type(conns2) == "table" then
        for _, conn in ipairs(conns2) do
            if type(conn. Function) == "function" then
                table.insert(data.triggerCallbacks, conn.Function)
            end
        end
    end
    
    if (#data.holdCallbacks > 0) or (#data.triggerCallbacks > 0) then
        InternalStealCache[prompt] = data
    end
end

local function runCallbackList(list)
    for _, fn in ipairs(list) do
        task.spawn(fn)
    end
end

local function executeInternalStealAsync(prompt)
    local data = InternalStealCache[prompt]
    if not data or not data.ready then return false end
    
    data.ready = false
    
    task.spawn(function()
        if #data.holdCallbacks > 0 then
            runCallbackList(data.holdCallbacks)
        end
        
        task.wait(1. 3)
        
        if #data.triggerCallbacks > 0 then
            runCallbackList(data.triggerCallbacks)
        end
        
        task.wait()
        data.ready = true
    end)
    
    return true
end

local function attemptSteal(prompt)
    if not prompt or not prompt.Parent then
        return false
    end
    
    buildStealCallbacks(prompt)
    if not InternalStealCache[prompt] then
        return false
    end
    
    return executeInternalStealAsync(prompt)
end

local function getPriorityAnimal()
    local PRIORITY_ANIMALS = getgenv().BRAINROT_FAVORITES or {}
    
    for _, priorityName in ipairs(PRIORITY_ANIMALS) do
        for _, animalData in ipairs(BrainrotLib.allAnimalsCache) do
            if not isMyBaseAnimal(animalData) and animalData.name == priorityName then
                return animalData
            end
        end
    end
    return nil
end

local stealConnection = nil
local velocityConnection = nil

function BrainrotLib.StartAutoSteal(config)
    if stealConnection then
        stealConnection:Disconnect()
    end
    if velocityConnection then
        velocityConnection:Disconnect()
    end
    
    velocityConnection = S.RunService.Heartbeat:Connect(function()
        updatePlayerVelocity()
    end)
    
    stealConnection = S. RunService.Heartbeat:Connect(function()
        if not config.AUTO_STEAL_ENABLED and not config.AUTO_STEAL_NEAREST_ENABLED and not config.AUTO_STEAL_PRIORITY_ENABLED then
            return
        end
        
        local targetAnimal = nil
        
        if config.AUTO_STEAL_PRIORITY_ENABLED then
            targetAnimal = getPriorityAnimal()
            
            if not targetAnimal then
                if config.AUTO_STEAL_NEAREST_ENABLED then
                    targetAnimal = getNearestAnimal()
                elseif config.AUTO_STEAL_ENABLED then
                    for _, animal in ipairs(BrainrotLib.allAnimalsCache) do
                        if not isMyBaseAnimal(animal) then
                            targetAnimal = animal
                            break
                        end
                    end
                end
            end
        elseif config.AUTO_STEAL_NEAREST_ENABLED then
            targetAnimal = getNearestAnimal()
        elseif config.AUTO_STEAL_ENABLED then
            for _, animal in ipairs(BrainrotLib.allAnimalsCache) do
                if not isMyBaseAnimal(animal) then
                    targetAnimal = animal
                    break
                end
            end
        end
        
        if not targetAnimal or isMyBaseAnimal(targetAnimal) then
            return
        end
        
        if not shouldPreFire(targetAnimal, config. PREDICTIVE_STEAL or false) then
            return
        end
        
        if LastTargetUID ~= targetAnimal.uid then
            LastTargetUID = targetAnimal.uid
        end
        
        local prompt = PromptMemoryCache[targetAnimal.uid]
        if not prompt or not prompt.Parent then
            prompt = findProximityPromptForAnimal(targetAnimal)
        end
        
        if prompt then
            attemptSteal(prompt)
        end
    end)
end

function BrainrotLib.StopAutoSteal()
    if stealConnection then
        stealConnection:Disconnect()
        stealConnection = nil
    end
    if velocityConnection then
        velocityConnection:Disconnect()
        velocityConnection = nil
    end
end

-- ============================================================
-- SPEED BOOST SYSTEM
-- ============================================================

function BrainrotLib.StartStealSpeed()
    if stealSpeedConn then return end

    stealSpeedConn = S.RunService.Heartbeat:Connect(function()
        if not S.LocalPlayer:GetAttribute("Stealing") then return end

        local char = S.LocalPlayer.Character
        if not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid")
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hum or not hrp then return end

        local move = hum. MoveDirection
        if move.Magnitude > 0 then
            hrp.AssemblyLinearVelocity = Vector3.new(
                move.X * STEAL_SPEED,
                hrp.AssemblyLinearVelocity.Y,
                move.Z * STEAL_SPEED
            )
        end
    end)
end

function BrainrotLib.StopStealSpeed()
    if stealSpeedConn then
        stealSpeedConn:Disconnect()
        stealSpeedConn = nil
    end
end

-- ============================================================
-- ANIMATION DISABLER
-- ============================================================

local animDisableConn = nil
local originalAnimIds = {}
local animateScript = nil

local ANIM_TYPES = {
    "walk", "run", "jump", "fall"
}

local function cacheOriginalAnimations()
    local char = S.LocalPlayer.Character
    if not char then return false end
    
    animateScript = char:FindFirstChild("Animate")
    if not animateScript then return false end
    
    originalAnimIds = {}
    
    for _, animType in ipairs(ANIM_TYPES) do
        local animFolder = animateScript:FindFirstChild(animType)
        if animFolder then
            originalAnimIds[animType] = {}
            for _, anim in ipairs(animFolder: GetChildren()) do
                if anim:IsA("Animation") then
                    originalAnimIds[animType][anim.Name] = anim. AnimationId
                end
            end
        end
    end
    
    return true
end

local function disableAnimations()
    if not animateScript then return end
    
    for _, animType in ipairs(ANIM_TYPES) do
        local animFolder = animateScript:FindFirstChild(animType)
        if animFolder then
            for _, anim in ipairs(animFolder:GetChildren()) do
                if anim: IsA("Animation") then
                    anim.AnimationId = ""
                end
            end
        end
    end
    
    local char = S.LocalPlayer.Character
    if char then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                track:Stop(0)
            end
        end
    end
end

local function restoreAnimations()
    if not animateScript or not originalAnimIds then return end
    
    for animType, anims in pairs(originalAnimIds) do
        local animFolder = animateScript:FindFirstChild(animType)
        if animFolder then
            for animName, animId in pairs(anims) do
                local anim = animFolder:FindFirstChild(animName)
                if anim and anim:IsA("Animation") then
                    anim.AnimationId = animId
                end
            end
        end
    end
end

function BrainrotLib.StartAnimDisable()
    if animDisableConn then return end
    
    if not next(originalAnimIds) then
        if not cacheOriginalAnimations() then
            warn("[Anim Disable] Failed to cache animations")
            return false
        end
    end

    animDisableConn = S.RunService.Heartbeat:Connect(function()
        if not S.LocalPlayer:GetAttribute("Stealing") then return end
        disableAnimations()
    end)
    
    return true
end

function BrainrotLib.StopAnimDisable()
    if animDisableConn then
        animDisableConn:Disconnect()
        animDisableConn = nil
    end
    restoreAnimations()
end

S.LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    originalAnimIds = {}
    animateScript = nil
    cacheOriginalAnimations()
end)

-- ============================================================
-- OPTIMIZER MODULE
-- ============================================================

BrainrotLib. OPTIMIZER = {}
local optimizerThreads = {}
local optimizerConnections = {}
local originalSettings = {}

local function addThread(func)
    local t = task.spawn(func)
    table.insert(optimizerThreads, t)
    return t
end

local function addConnection(conn)
    table.insert(optimizerConnections, conn)
    return conn
end

local function storeOriginalSettings()
    pcall(function()
        originalSettings = {
            streamingEnabled = workspace.StreamingEnabled,
            streamingMinRadius = workspace.StreamingMinRadius,
            streamingTargetRadius = workspace.StreamingTargetRadius,
            
            qualityLevel = settings().Rendering.QualityLevel,
            meshPartDetailLevel = settings().Rendering.MeshPartDetailLevel,
            
            globalShadows = S.Lighting.GlobalShadows,
            brightness = S.Lighting.Brightness,
            fogEnd = S.Lighting.FogEnd,
            technology = S.Lighting.Technology,
            environmentDiffuseScale = S.Lighting.EnvironmentDiffuseScale,
            environmentSpecularScale = S. Lighting.EnvironmentSpecularScale,
            
            decoration = workspace.Terrain.Decoration,
            waterWaveSize = workspace.Terrain.WaterWaveSize,
            waterWaveSpeed = workspace.Terrain.WaterWaveSpeed,
            waterReflectance = workspace.Terrain.WaterReflectance,
            waterTransparency = workspace.Terrain. WaterTransparency,
        }
    end)
end

local PERFORMANCE_FFLAGS = {
    ["DFIntTaskSchedulerTargetFps"] = 999,
    ["FFlagDebugGraphicsPreferVulkan"] = true,
    ["FFlagDebugGraphicsDisableDirect3D11"] = true,
    ["FFlagDebugGraphicsPreferD3D11FL10"] = false,
    ["DFFlagDebugRenderForceTechnologyVoxel"] = true,
    ["FFlagDisablePostFx"] = true,
    ["FIntRenderShadowIntensity"] = 0,
    ["FIntRenderLocalLightUpdatesMax"] = 0,
    ["FIntRenderLocalLightUpdatesMin"] = 0,
    ["DFIntTextureCompositorActiveJobs"] = 1,
    ["DFIntDebugFRMQualityLevelOverride"] = 1,
    
    ["FFlagFixPlayerCollisionWhenSwimming"] = false,
    ["DFIntMaxInterpolationSubsteps"] = 0,
    ["DFIntS2PhysicsSenderRate"] = 15,
    
    ["DFIntConnectionMTUSize"] = 1492,
    ["DFIntHttpCurlConnectionCacheSize"] = 134217728,
    
    ["DFIntCSGLevelOfDetailSwitchingDistance"] = 0,
    ["DFIntCSGLevelOfDetailSwitchingDistanceL12"] = 0,
    ["DFIntCSGLevelOfDetailSwitchingDistanceL23"] = 0,
    ["DFIntCSGLevelOfDetailSwitchingDistanceL34"] = 0,
    
    ["FFlagEnableInGameMenuChromeABTest3"] = false,
    ["FFlagEnableInGameMenuModernization"] = false,
    ["FFlagEnableReportAbuseMenuRoactABTest2"] = false,
    ["FFlagDisableNewIGMinDUA"] = true,
    ["FFlagEnableAccessoryValidation"] = false,
    ["FFlagEnableV3MenuABTest3"] = false,
    
    ["FIntRobloxGuiBlurIntensity"] = 0,
    ["DFIntTimestepArbiterThresholdCFLThou"] = 10,
    
    ["DFIntTextureQualityOverride"] = 1,
    ["DFIntPerformanceControlTextureQualityBestUtility"] = 1,
    ["DFIntTexturePoolSizeMB"] = 64,
    
    ["DFIntMaxFrameBufferSize"] = 1,
    
    ["FFlagDebugDisableParticleRendering"] = false,
    ["DFIntParticleMaxCount"] = 100,
    
    ["FFlagEnableWaterReflections"] = false,
    ["DFIntWaterReflectionQuality"] = 0,
}

local function applyFFlags()
    local success = 0
    local failed = 0
    
    for flag, value in pairs(PERFORMANCE_FFLAGS) do
        local ok = pcall(function()
            setfflag(flag, tostring(value))
        end)
        
        if ok then
            success = success + 1
        else
            failed = failed + 1
        end
    end
end

local function nukeVisualEffects()
    pcall(function()
        for _, obj in ipairs(workspace:GetDescendants()) do
            pcall(function()
                if obj:IsA("ParticleEmitter") then
                    obj. Enabled = false
                    obj.Rate = 0
                    obj: Destroy()
                    
                elseif obj:IsA("Trail") then
                    obj. Enabled = false
                    obj: Destroy()
                    
                elseif obj:IsA("Beam") then
                    obj. Enabled = false
                    obj: Destroy()
                    
                elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
                    obj.Enabled = false
                    obj. Brightness = 0
                    obj: Destroy()
                    
                elseif obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
                    obj. Enabled = false
                    obj: Destroy()
                    
                elseif obj:IsA("Explosion") then
                    obj: Destroy()
                    
                elseif obj:IsA("SpecialMesh") then
                    obj.TextureId = ""
                    
                elseif obj:IsA("Decal") or obj:IsA("Texture") then
                    if not (obj.Name == "face" and obj.Parent and obj.Parent.Name == "Head") then
                        obj. Transparency = 1
                    end
                    
                elseif obj:IsA("BasePart") then
                    obj.CastShadow = false
                    obj.Material = Enum.Material.Plastic
                    
                    if obj.Material == Enum.Material.Glass then
                        obj. Reflectance = 0
                    end
                end
            end)
        end
    end)
end

function BrainrotLib. OPTIMIZER.Enable()
    if getgenv().OPTIMIZER_ACTIVE then 
        return 
    end
    
    getgenv().OPTIMIZER_ACTIVE = true
    storeOriginalSettings()
    
    pcall(applyFFlags)
    
    pcall(function()
        workspace.StreamingEnabled = true
        workspace. StreamingMinRadius = 64
        workspace.StreamingTargetRadius = 256
        workspace.StreamingIntegrityMode = Enum.StreamingIntegrityMode.MinimumRadiusPause
    end)
    
    pcall(function()
        local renderSettings = settings().Rendering
        renderSettings. QualityLevel = Enum.QualityLevel.Level01
        renderSettings.MeshPartDetailLevel = Enum.MeshPartDetailLevel.Level01
        renderSettings.EditQualityLevel = Enum.QualityLevel.Level01
        
        S.Lighting.GlobalShadows = false
        S.Lighting. Brightness = 3
        S.Lighting.FogEnd = 9e9
        S.Lighting. Technology = Enum.Technology.Legacy
        S.Lighting. EnvironmentDiffuseScale = 0
        S.Lighting.EnvironmentSpecularScale = 0
        
        for _, effect in ipairs(S.Lighting:GetChildren()) do
            if effect:IsA("PostEffect") then
                pcall(function() 
                    effect.Enabled = false 
                    effect: Destroy()
                end)
            end
        end
        
        local atmo = S.Lighting:FindFirstChildOfClass("Atmosphere")
        if atmo then atmo: Destroy() end
        
        local bloom = S.Lighting:FindFirstChildOfClass("BloomEffect")
        if bloom then bloom:Destroy() end
        
        local blur = S.Lighting:FindFirstChildOfClass("BlurEffect")
        if blur then blur: Destroy() end
        
        local cc = S.Lighting:FindFirstChildOfClass("ColorCorrectionEffect")
        if cc then cc:Destroy() end
        
        local sunrays = S.Lighting:FindFirstChildOfClass("SunRaysEffect")
        if sunrays then sunrays: Destroy() end
        
        local dof = S.Lighting:FindFirstChildOfClass("DepthOfFieldEffect")
        if dof then dof:Destroy() end
    end)
    
    pcall(function()
        local physics = settings().Physics
        physics.AllowSleep = true
        physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Skip
        physics.ThrottleAdjustTime = 0
    end)
    
    pcall(function()
        workspace.Terrain.WaterWaveSize = 0
        workspace.Terrain.WaterWaveSpeed = 0
        workspace.Terrain.WaterReflectance = 0
        workspace.Terrain.WaterTransparency = 1
        workspace.Terrain.Decoration = false
    end)
    
    addThread(function()
        task.wait(1)
        nukeVisualEffects()
    end)
    
    addConnection(workspace.DescendantAdded:Connect(function(obj)
        if not getgenv().OPTIMIZER_ACTIVE then return end
        
        pcall(function()
            if obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or
               obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") or
               obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") or obj:IsA("Explosion") then
                obj: Destroy()
            elseif obj:IsA("BasePart") then
                obj. CastShadow = false
                obj.Material = Enum. Material.Plastic
            end
        end)
    end))
    
    local function optimizeCharacter(char)
        if not char then return end
        
        task.spawn(function()
            task.wait(0.5)
            
            pcall(function()
                for _, part in ipairs(char: GetDescendants()) do
                    pcall(function()
                        if part:IsA("BasePart") then
                            part.CastShadow = false
                            part.Material = Enum. Material.Plastic
                            part.Reflectance = 0
                            
                        elseif part:IsA("ParticleEmitter") or part:IsA("Trail") or part:IsA("Beam") then
                            part: Destroy()
                            
                        elseif part: IsA("PointLight") or part:IsA("SpotLight") or part:IsA("SurfaceLight") then
                            part:Destroy()
                            
                        elseif part: IsA("Fire") or part:IsA("Smoke") or part:IsA("Sparkles") then
                            part:Destroy()
                        end
                    end)
                end
            end)
        end)
    end
    
    for _, player in ipairs(S.Players:GetPlayers()) do
        if player.Character then
            optimizeCharacter(player.Character)
        end
        
        addConnection(player.CharacterAdded:Connect(function(char)
            if getgenv().OPTIMIZER_ACTIVE then
                optimizeCharacter(char)
            end
        end))
    end
    
    addConnection(S.Players.PlayerAdded:Connect(function(player)
        addConnection(player.CharacterAdded:Connect(function(char)
            if getgenv().OPTIMIZER_ACTIVE then
                optimizeCharacter(char)
            end
        end))
    end))
    
    addThread(function()
        while getgenv().OPTIMIZER_ACTIVE do
            task.wait(15)
            
            pcall(function()
                collectgarbage("collect")
            end)
        end
    end)
    
    pcall(function()
        setfpscap(999)
    end)
    
    pcall(function()
        local cam = workspace.CurrentCamera
        cam. FieldOfView = 70
    end)
end

function BrainrotLib. OPTIMIZER.Disable()
    if not getgenv().OPTIMIZER_ACTIVE then return end
    
    getgenv().OPTIMIZER_ACTIVE = false
    
    for _, thread in ipairs(optimizerThreads) do
        pcall(function()
            task.cancel(thread)
        end)
    end
    optimizerThreads = {}
    
    for _, conn in ipairs(optimizerConnections) do
        pcall(function()
            conn:Disconnect()
        end)
    end
    optimizerConnections = {}
    
    pcall(function()
        workspace.StreamingEnabled = originalSettings.streamingEnabled or true
        workspace.StreamingMinRadius = originalSettings.streamingMinRadius or 64
        workspace.StreamingTargetRadius = originalSettings. streamingTargetRadius or 1024
        
        settings().Rendering.QualityLevel = originalSettings.qualityLevel or Enum.QualityLevel. Automatic
        settings().Rendering.MeshPartDetailLevel = originalSettings. meshPartDetailLevel or Enum. MeshPartDetailLevel. DistanceBased
        
        S.Lighting.GlobalShadows = originalSettings.globalShadows ~= false
        S.Lighting.Brightness = originalSettings.brightness or 1
        S.Lighting.FogEnd = originalSettings.fogEnd or 100000
        S.Lighting.Technology = originalSettings.technology or Enum.Technology.ShadowMap
        S. Lighting.EnvironmentDiffuseScale = originalSettings.environmentDiffuseScale or 1
        S.Lighting. EnvironmentSpecularScale = originalSettings.environmentSpecularScale or 1
        
        workspace.Terrain.WaterWaveSize = originalSettings.waterWaveSize or 0.15
        workspace.Terrain.WaterWaveSpeed = originalSettings. waterWaveSpeed or 10
        workspace.Terrain.WaterReflectance = originalSettings.waterReflectance or 1
        workspace.Terrain.WaterTransparency = originalSettings. waterTransparency or 0.3
        workspace.Terrain.Decoration = originalSettings.decoration ~= false
    end)
end

-- ============================================================
-- ANTI-LAG SYSTEM
-- ============================================================

BrainrotLib.ANTI_LAG = {}
local antiLagRunning = false
local antiLagConnections = {}
local cleanedCharacters = {}

local function destroyAllEquippableItems(character)
    if not character then return end
    
    pcall(function()
        for _, child in ipairs(character:GetChildren()) do
            if child:IsA("Accessory") or child:IsA("Hat") then
                child:Destroy()
            end
        end
        
        for _, child in ipairs(character:GetChildren()) do
            if child:IsA("Shirt") or child:IsA("Pants") or child:IsA("ShirtGraphic") then
                child:Destroy()
            end
        end
        
        local bodyColors = character:FindFirstChildOfClass("BodyColors")
        if bodyColors then
            bodyColors:Destroy()
        end
        
        for _, child in ipairs(character:GetChildren()) do
            if child:IsA("CharacterMesh") then
                child:Destroy()
            end
        end
        
        for _, child in ipairs(character:GetDescendants()) do
            if child. ClassName == "LayeredClothing" or child.ClassName == "WrapLayer" then
                child:Destroy()
            end
        end
        
        for _, child in ipairs(character:GetChildren()) do
            if child:IsA("BasePart") then
                local mesh = child:FindFirstChildOfClass("SpecialMesh")
                if mesh then
                    mesh: Destroy()
                end
            end
        end
        
        for _, child in ipairs(character:GetDescendants()) do
            if child: IsA("ParticleEmitter") or child:IsA("Trail") or child:IsA("Beam") then
                child:Destroy()
            end
        end
        
        for _, child in ipairs(character:GetDescendants()) do
            if child:IsA("PointLight") or child:IsA("SpotLight") or child:IsA("SurfaceLight") then
                child:Destroy()
            end
        end
        
        for _, child in ipairs(character: GetDescendants()) do
            if child:IsA("Fire") or child:IsA("Smoke") or child:IsA("Sparkles") then
                child: Destroy()
            end
        end
        
        for _, child in ipairs(character:GetDescendants()) do
            if child:IsA("Highlight") then
                child:Destroy()
            end
        end
        
        for _, child in ipairs(character:GetDescendants()) do
            if child:IsA("Decal") or child:IsA("Texture") then
                if not (child.Name == "face" and child.Parent and child. Parent.Name == "Head") then
                    child: Destroy()
                end
            end
        end
    end)
end

local function destroyBackpackTools(player)
    pcall(function()
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            for _, tool in ipairs(backpack:GetChildren()) do
                if tool:IsA("Tool") then
                    for _, desc in ipairs(tool:GetDescendants()) do
                        if desc:IsA("ParticleEmitter") or desc:IsA("Trail") or desc:IsA("Beam") or
                           desc:IsA("SpecialMesh") or desc:IsA("PointLight") or desc:IsA("SpotLight") or
                           desc:IsA("Fire") or desc:IsA("Smoke") or desc:IsA("Sparkles") then
                            desc:Destroy()
                        end
                    end
                end
            end
        end
    end)
end

local function destroyEquippedTools(character)
    if not character then return end
    
    pcall(function()
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                for _, desc in ipairs(tool: GetDescendants()) do
                    if desc:IsA("ParticleEmitter") or desc:IsA("Trail") or desc:IsA("Beam") or
                       desc:IsA("SpecialMesh") or desc:IsA("PointLight") or desc:IsA("SpotLight") or
                       desc:IsA("Fire") or desc:IsA("Smoke") or desc:IsA("Sparkles") then
                        desc:Destroy()
                    end
                end
            end
        end
    end)
end

local function antiLagCleanCharacter(char)
    if not char then return end
    
    destroyAllEquippableItems(char)
    destroyEquippedTools(char)
    cleanedCharacters[char] = true
end

local function antiLagDisconnectAll()
    for _, conn in ipairs(antiLagConnections) do
        if typeof(conn) == "RBXScriptConnection" then
            conn:Disconnect()
        end
    end
    antiLagConnections = {}
    cleanedCharacters = {}
end

function BrainrotLib.ANTI_LAG.Enable()
    if antiLagRunning then return end
    antiLagRunning = true
    
    for _, plr in ipairs(S.Players:GetPlayers()) do
        if plr.Character then
            antiLagCleanCharacter(plr.Character)
            destroyBackpackTools(plr)
        end
        
        if plr. Backpack then
            table.insert(antiLagConnections, plr.Backpack. ChildAdded:Connect(function()
                if antiLagRunning then
                    task.wait(0.1)
                    destroyBackpackTools(plr)
                end
            end))
        end
    end
    
    table.insert(antiLagConnections, S.Players.PlayerAdded:Connect(function(plr)
        table.insert(antiLagConnections, plr.CharacterAdded:Connect(function(char)
            if not antiLagRunning then return end
            task.wait(0.5)
            antiLagCleanCharacter(char)
            destroyBackpackTools(plr)
            
            table.insert(antiLagConnections, char.ChildAdded:Connect(function(child)
                if not antiLagRunning then return end
                task.wait(0.1)
                
                if child:IsA("Accessory") or child:IsA("Hat") or child:IsA("Shirt") or 
                   child:IsA("Pants") or child:IsA("ShirtGraphic") then
                    child:Destroy()
                elseif child:IsA("Tool") then
                    destroyEquippedTools(char)
                end
            end))
        end))
        
        if plr.Character then
            antiLagCleanCharacter(plr.Character)
            destroyBackpackTools(plr)
        end
        
        if plr.Backpack then
            table.insert(antiLagConnections, plr.Backpack.ChildAdded:Connect(function()
                if antiLagRunning then
                    task.wait(0.1)
                    destroyBackpackTools(plr)
                end
            end))
        end
    end))
    
    for _, plr in ipairs(S.Players:GetPlayers()) do
        table.insert(
